import { Injectable, Logger } from '@nestjs/common';
import { DataSource } from 'typeorm';
import { WatchPartyLog } from './entities/watch-party-log.entity';
import { WatchParty } from './entities/watch-party.entity';

@Injectable()
export class WatchPartyPersistenceService {
  private readonly logger = new Logger(WatchPartyPersistenceService.name);

  constructor(private readonly dataSource: DataSource) {}

  async bulkInsertLogs(
    partyId: string,
    logs: Partial<WatchPartyLog>[],
  ): Promise<void> {
    if (logs.length === 0) {
      return;
    }

    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // We can't use repository.insert because it doesn't allow for `ON CONFLICT`
      // and we need to ensure idempotency.
      // A raw query or QueryBuilder is more appropriate here.
      // The `id` is generated by the application (e.g., uuidv4) before being buffered.

      await queryRunner.manager
        .createQueryBuilder()
        .insert()
        .into(WatchPartyLog)
        .values(
          logs.map((log) => ({
            ...log,
            watch_party: { id: partyId } as WatchParty,
          })),
        )
        .orIgnore() // This is equivalent to ON CONFLICT DO NOTHING for supported drivers (like Postgres)
        .execute();

      await queryRunner.commitTransaction();
      this.logger.log(
        `Successfully flushed ${logs.length} logs for party ${partyId}.`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to flush logs for party ${partyId}. Rolling back.`,
        error.stack,
      );
      await queryRunner.rollbackTransaction();
      // In a production system, we would push the failed batch to a DLQ (Dead-Letter Queue)
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  async updateWatchPartyCounters(
    partyId: string,
    likesMap: Map<string, number>,
    totalViewers: number,
  ): Promise<void> {
    try {
      const likesObj = Object.fromEntries(likesMap);

      await this.dataSource.getRepository(WatchParty).update(partyId, {
        total_likes: likesObj,
      });
    } catch (error) {
      this.logger.error(
        `Failed to update counters for party ${partyId}.`,
        error.stack,
      );
      // This failure is less critical than losing logs, but should still be monitored.
    }
  }
}
